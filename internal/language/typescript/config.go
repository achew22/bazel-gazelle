/* Copyright 2018 The Bazel Authors. All rights reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package typescript

import (
	"flag"
	"fmt"
	"log"
	"path"

	"github.com/bazelbuild/bazel-gazelle/internal/config"
	"github.com/bazelbuild/bazel-gazelle/internal/rule"
)

// TypeScriptConfig contains configuration values related to typescript.
//
// This type is public because other languages need to generate rules based
// on typescripts, so this configuration may be relevant to them.
type TypeScriptConfig struct {
	// Mode determines how rules are generated for typescripts.
	Mode Mode

	// ModeExplicit indicates whether the typescript mode was set explicitly.
	ModeExplicit bool
}

func GetTypeScriptConfig(c *config.Config) *TypeScriptConfig {
	return c.Exts[typescriptName].(*TypeScriptConfig)
}

// Mode determines how typescript rules are generated.
type Mode int

const (
	// DefaultMode generates typescript_library rules.
	DefaultMode Mode = iota

	// DisableMode ignores .ts files and generates empty typescript_library rules.
	// Checked-in generated files (e.g., .pb.go files) should be treated as
	// normal sources.
	DisableMode
)

func ModeFromString(s string) (Mode, error) {
	switch s {
	case "default":
		return DefaultMode, nil
	case "disable":
		return DisableMode, nil
	default:
		return 0, fmt.Errorf("unrecognized typescript mode: %q", s)
	}
}

func (m Mode) String() string {
	switch m {
	case DefaultMode:
		return "default"
	case DisableMode:
		return "disable"
	default:
		log.Panicf("unknown mode %d", m)
		return ""
	}
}

type modeFlag struct {
	mode *Mode
}

func (f *modeFlag) Set(value string) error {
	if mode, err := ModeFromString(value); err != nil {
		return err
	} else {
		*f.mode = mode
		return nil
	}
}

func (f *modeFlag) String() string {
	var mode Mode
	if f != nil {
		mode = *f.mode
	}
	return mode.String()
}

func (_ *typescriptLang) RegisterFlags(fs *flag.FlagSet, cmd string, c *config.Config) {
	pc := &TypeScriptConfig{}
	c.Exts[typescriptName] = pc

	// Note: the -typescript flag does not set the ModeExplicit flag. We want to
	// be able to switch to DisableMode in vendor directories, even when
	// this is set for compatibility with older versions.
	fs.Var(&modeFlag{&pc.Mode}, "typescript", "default: generates new typescript rules\n\tdisable: does not touch typescript rules\n\t")
}

func (_ *typescriptLang) CheckFlags(fs *flag.FlagSet, c *config.Config) error {
	return nil
}

func (_ *typescriptLang) KnownDirectives() []string {
	return []string{"typescript"}
}

func (_ *typescriptLang) Configure(c *config.Config, rel string, f *rule.File) {
	pc := &TypeScriptConfig{}
	*pc = *GetTypeScriptConfig(c)
	c.Exts[typescriptName] = pc
	if f != nil {
		for _, d := range f.Directives {
			switch d.Key {
			case "typescript":
				mode, err := ModeFromString(d.Value)
				if err != nil {
					log.Print(err)
					continue
				}
				pc.Mode = mode
				pc.ModeExplicit = true
			}
		}
	}
	inferTypeScriptMode(c, rel, f)
}

// inferTypeScriptMode sets TypeScriptConfig.Mode based on the directory name and the
// contents of f. If the typescript mode is set explicitly, this function does not
// change it. If this is a vendor directory, or go_typescript_library is loaded from
// another file, typescript rule generation is disabled.
//
// TODO(jayconrod): this logic is archaic, now that rules are generated by
// separate language extensions. TypeScript rule generation should be independent
// from Go.
func inferTypeScriptMode(c *config.Config, rel string, f *rule.File) {
	pc := GetTypeScriptConfig(c)
	if pc.Mode != DefaultMode || pc.ModeExplicit {
		return
	}
	if path.Base(rel) == "vendor" {
		pc.Mode = DisableMode
		return
	}
	if f == nil {
		return
	}
	mode := DefaultMode
outer:
	for _, l := range f.Loads {
		name := l.Name()
		if name == "@io_bazel_rules_go//typescript:def.bzl" {
			break
		}
		for _, sym := range l.Symbols() {
			if sym == "go_typescript_library" {
				mode = DisableMode
				break outer
			}
		}
	}
	if mode == DefaultMode || pc.Mode == mode {
		return
	}
	pc.Mode = mode
}
